<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<rfc submissionType="IETF"
     docName="draft-rhrd-tls-tls13-visibility-00"
     category="info">
<?rfc compact="yes"?>
<?rfc text-list-symbols="o*+-"?>
<?rfc subcompact="no"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
  <front>
    <title abbrev="Option for TLS 1.3 in Datacenter">TLS 1.3 Option
    for Negotiation of Visibility in the Datacenter</title>

    <author fullname="Russ Housley" initials="R." surname="Housley">
      <organization>Vigil Security, LLC</organization>
      <address>
        <postal>
          <street>918 Spring Knoll Drive</street>
          <city>Herndon</city>
          <region>VA</region>
          <code>20170</code>
          <country>USA</country>
        </postal>
        <email>housley@vigilsec.com</email>
      </address>
    </author>

    <author fullname="Ralph Droms" initials="R." surname="Droms">
      <organization>Interisle Consulting</organization>
      <address>
        <email>rdroms.ietf@gmail.com</email>
      </address>
    </author>

    <date year="2017"/>
    <abstract>
      <t>ABSTRACT</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction" anchor="section-intro">
      <t>INTRODCUTION</t>
    </section>

    <section title="TLS Visibility Extension"
             anchor="section-extension">
      <t>This section specifies the "tls_visibility" extension, which
      is carried in the ClienHello message and the ServerHello
      message.
      </t>

      <t>
        The general extension mechanisms enable clients and servers to
        negotiate the use of specific extensions.  As specified in
        <xref target="I-D.ietf-tls-tls13" />, clients request extended
        functionality from servers with the extensions field in the
        ClienHello message.  If the server responds HelloRetryRequest,
        then the client sends another ClientHello message that
        includes the same extensions field as the original ClienHello
        message.
      </t>

      <t>
        Most server extensions are carried in the EncryptedExtensions
        message; however, the "tls_visibility" extension is carried in
        the ServerHello message in a manner similar to the "key_share"
        and "pre_shared_key" extensions.  It is only present in the
        ServerHello message if the server wants to enable TLS
        Visibility for some other parties and the client has offered
        the "tls_visibility" extension in the ClientHello message.
      </t>

      <t>
        The "tls_visibility" extension MUST NOT appear in the
        ServerHello message unless "tls_visibility" extension appeared
        in the preceding ClientHello message.  The Figure 2 provides
        an additional row for the table in Section 4.2 of
	<xref target="I-D.ietf-tls-tls13" />.  It indicates that the
	"tls_visibility" extension may appear in the CH (ClientHello
	message) and SH (ServerHello message), and it MUST NOT appear
	in any other messages.  If an implementation recognizes the
	"tls_visibility" extension and receives it in any other
	message, then the implementation MUST abort the handshake with
	an "illegal_parameter" alert.
      </t>

      <t>
        <figure align="center" anchor="table-extension"
                title="Additional row for the TLS 1.3 extension table">
          <artwork align="center"><![CDATA[
  +--------------------------------------------------+-------------+
  | Extension                                        |     TLS 1.3 |
  +--------------------------------------------------+-------------+
  | tls_visibility                                   |      CH, SH |
  +--------------------------------------------------+-------------+
]]>
          </artwork>
        </figure>
      </t>
      
      <t>
        The Extension structure is defined in
	<xref target="I-D.ietf-tls-tls13" />; it is repeated here for
	convenience.
      </t>

      <t>
        <figure align="left">
          <artwork align="left"><![CDATA[
    struct {
        ExtensionType extension_type;
        opaque extension_data<0..2^16-1>;
    } Extension;
]]>
          </artwork>
        </figure>
      </t>

      <t>
        The "extension_type" identifies the particular extension type,
        and the "extension_data" contains information specific to the
        particular extension type.
      </t>

      <t>
        This document specifies the "tls_visibility" extension type,
        adding one new type to ExtensionType:
      </t>

      <t>
        <figure align="left">
          <artwork align="left"><![CDATA[
    enum {
        tls_visibility(TBD), (65535)
    } ExtensionType;
]]>
          </artwork>
        </figure>
      </t>
      
      <t>
        The "tls_visibility" extension is relevant when the client and
        server are enabling other parties to decrypt the TLS session.
      </t>

      <t>
        Clients MUST include the "tls_visibility" extension in the
        ClientHello message to indicate their willingness for other
        parties to decrypt the TLS session.  The server responds with
        data that enables the other parties to derive the keying
        material needed decryption the session if they are in
        possession of the indicated ECDH private key.
      </t>

      <t>
        <figure align="left">
          <artwork align="left"><![CDATA[
  struct {
      select (Handshake.msg_type) {
          case client_hello:  Empty;
          case server_hello:  WrappedSessionSecrets visibility_data;
      };
  } TLSVisibilityExtension;

  struct {
      opaque early_secret<1..255>;
      opaque hs_secret<1..255>;
  } SessionSecrets;

  struct {
      opaque fingerprint<20>;
      opaque key_exchange<1..2^16-1>;
      opaque nonce<0..255>;
      opaque wrapped_secrets<1..2^16-1>;
  } WrappedSessionSecrets;
]]>
          </artwork>
        </figure>
      </t>
      
      <t>
        The fields in WrappedSessionSecrets are used as follows:

        <list style="symbols">
          <t>
            "fingerprint" contains the leftmost 20 octets of the
            SHA-256 hash of ECDH public key that was used by the
            server to compute the session secret wrapping key.  The
            public key is DER-encoded in the SubjectPublicKeyInfo
            [RFC5280] for the SHA-256 hash computation.  The key
            manager tells the server which AEAD algorithm to use with
            this ECDH public key at the time it is distributed.
          </t>

          <t>
            "key_exchange" contains the ephemeral ECDH public key
            generated by the server that is part of the same group as
            the ECDH public key identified by the "fingerprint".  The
            server uses the ephemeral ECDH private key and the ECDH
            public key identified by the "fingerprint" to compute a
            shared secret value, called Z, and then uses HKDF
            [RFC5869] to produce the session secret wrapping key,
            called Ke, which uses an AEAD algorithm, such as
            AES-KEY-WRAP-256 [RFC5649] or AES-GCM-128 [GCM].  Ke is
            computed as follows:

            <figure align="left">
              <artwork align="left"><![CDATA[
           PRK = HKDF-Extract(0x00, Z)
           Ke = HKDF-Expand(PRK, "tls_visibility", AEAD_key_size)
]]>
              </artwork>
            </figure>
          </t>

          <t>
            "nonce" contains the nonce value for AEAD algorithm, if
            one is needed.  The "nonce" is zero length if one is not
            needed.
          </t>

          <t>
            "wrapped_secrets" contains the SessionSecrets structure
            encrypted with the AEAD algorithm under Ke.
          </t>
        </list>
      </t>

      <t>
        The fields in SessionSecrets are used as follows:

        <list style="symbols">

          <t>
            "early_secret" contains the Early Secret that was derived
            from the pre-shared key.  If this session did not use a
            pre-shared key, then the Early Secret is HKDF-Extract(0,
            0).
          </t>

          <t>
            "hs_secret" contains the handshake key that was computed
            using (EC)DHE.
          </t>
        </list>
      </t>
    </section>
    
    <section title="IANA Considerations" anchor="section-IANA">
      <t>IANA CONSIDERATIONS</t>
    </section>

    <section title="Security Considerations"
             anchor="section-security">
      <t>SECURITY CONSIDERATIONS</t>
    </section>
    
    <section title="Acknowledgements" anchor="section-acks">
      <t>ACKNOWLEDGMENTS</t>
    </section>

  </middle>

  <back>
    <references title="Normative References">

      <?rfc include="reference.I-D.ietf-tls-tls13" ?>

    </references>
  </back>
  
</rfc>
        
