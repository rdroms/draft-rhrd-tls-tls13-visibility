<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<rfc submissionType="IETF"
     docName="draft-rhrd-tls-tls13-visibility-00"
     category="std"
     ipr="trust200902">
<?rfc compact="yes"?>
<?rfc text-list-symbols="o*+-"?>
<?rfc subcompact="no"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
  <front>
    <title abbrev="Option for TLS 1.3 in Datacenter">TLS 1.3 Option
    for Negotiation of Visibility in the Datacenter</title>

    <author fullname="Russ Housley" initials="R." surname="Housley">
      <organization>Vigil Security</organization>
      <address>
            <postal>
          <street>918 Spring Knoll Drive</street>
          <city>Herndon</city>
          <region>VA</region>
          <code>20170</code>
          <country>USA</country>
            </postal>
            <email>housley@vigilsec.com</email>
      </address>
    </author>

    <author fullname="Ralph Droms" initials="R." surname="Droms">
      <organization>Interisle Consulting</organization>
      <address>
            <email>rdroms.ietf@gmail.com</email>
      </address>
    </author>

    <date year="2017"/>
    <abstract>
      <t>ABSTRACT</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction" anchor="section-1">
      <t>
	Unlike earlier versions of TLS, current drafts of TLS 1.3
	<xref target="I-D.ietf-tls-tls13" /> do not provide support
	for the RSA handshake -- and have instead adopted
	ephemeral-mode Diffie-Hellman (DHE) and elliptic-curve
	Diffie-Hellman (ECDHE) as the primary cryptographic key
	exchange mechanism used in TLS.
      </t>

      <t>
	While ephemeral (EC) Diffie-Hellman is in nearly all ways an
	improvement over the TLS RSA handshake, the use of these
	mechanisms complicates certain enterprise
	settings. Specifically, the use of ephemeral ciphersuites is
	not compatible with current enterprise network monitoring
	tools such as Intrusion Detection Systems (IDS) and
	application monitoring systems, which leverage the current TLS
	RSA handshake passively monitor intranet TLS connections made
	between endpoints under the enterprise's control. This traffic
	includes TLS connections made from enterprise network security
	devices (firewalls) and load balancers at the edge of the
	enterprise network to internal enterprise TLS servers. It does
	not include TLS connections traveling over the external
	Internet.
      </t>

      <t>
	Such monitoring of the enterprise network is ubiquitous and
	indispensable in some industries. This monitoring is required
	for effective and safe operation of enterprise networks. Loss
	of this capability may slow adoption of TLS 1.3.
      </t>

      <t>
	The use of the TLS Visibility Extension adds information to
	the initiation of a TLS 1.3 session that allows visibility
	into the session by an authorized third party.  Use of the
	extension requires opt-in by both endpoints of the TLS 1.3
	session.  The additional information in the TLS Visibility
	Extension is encrypted for privacy, and can only be decrypted
	with the private key from a managed Diffie-Hellman key pair.
      </t>

    </section>

    <section title="Terminology" anchor="section-term">
      <t>Two ECDH key pairs are used with the TLS Visibility Extension:
      <list style="hanging">
	<t hangText="WrapperDH1:">generated externally and provided to
	the TLS 1.3 servers prior to use of the TLS Visibility
	Extension</t>
	<t hangText="WrapperDH2:">generated by the server for each TLS
	1.3 session that uses the TLS Visibility Extension</t>
      </list>
      </t>
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described
      in <xref target="RFC2119" />.</t>
    </section>

    <section title="Extension Overview" anchor="section-over">
      <t>
	Prior to the use of the TLS Visibility Extension, the
	WrapperDH1 key pair is generated.  The private key is retained
	and the server is provisioned with the public key.  When a new
	TLS 1.3 session is initiated, the server generates a
	WrapperDH2 key pair.  The server then:
	<list style="symbols">
	  <t>generates a key, K, from the public WrapperDH1 key and the
	  private WrapperDH2 key</t>
	  <t>encrypts the TLS 1.3 session Early Secret and Handshake
	  Secret using K</t>
	  <t>sends an identifier for the public WrapperDH1 key, the
	  public WrapperDH2 key and the encrypted session secrets in
	  the TLS Visibility Extension</t>
	</list>
	To decrypt the TLS 1.3 session, the application
	or device must be given the private WrapperDH1 key paired with
	the public WrapperDH1 key identified in the extension.  The
	application or device uses the private WrapperDH1 key and the
	public WrapperDH2 key from the TLS Visibility Extension to
	generate K, which is then used to decrypt the session
	secrets.  The session secrets are then used to decrypt
	the TLS 1.3 session.
      </t>
    </section>

    <section title="TLS Visibility Extension" anchor="section-2">

      <t>
        This section specifies the "tls_visibility" extension, which
        is carried in the ClienHello message and the ServerHello
        message.
      </t>

      <t>
        The general extension mechanisms enable clients and servers to
        negotiate the use of specific extensions.  As specified in
        <xref target="I-D.ietf-tls-tls13"/>, clients request extended
        functionality from servers with the extensions field in the
        ClienHello message.  If the server responds HelloRetryRequest,
        then the client sends another ClientHello message that
        includes the same extensions field as the original ClienHello
        message.
      </t>

      <t>
        Most server extensions are carried in the EncryptedExtensions
        message; however, the "tls_visibility" extension is carried in
        the ServerHello message in a manner similar to the "key_share"
        and "pre_shared_key" extensions.  It is only present in the
        ServerHello message if the server wants to enable TLS
        Visibility for some other parties and the client has offered
        the "tls_visibility" extension in the ClientHello message.
      </t>

      <t>
        The "tls_visibility" extension MUST NOT appear in the
        ServerHello message unless "tls_visibility" extension appeared
        in the preceding ClientHello message.  The Figure 2 provides
        an additional row for the table in Section 4.2 of <xref
        target="I-D.ietf-tls-tls13"/>.  It indicates that the
        "tls_visibility" extension may appear in the CH (ClientHello
        message) and SH (ServerHello message), and it MUST NOT appear
        in any other messages.  If an implementation recognizes the
        "tls_visibility" extension and receives it in any other
        message, then the implementation MUST abort the handshake with
        an "illegal_parameter" alert.
      </t>

      <figure anchor="extn-table"
              title="Additional row for the TLS 1.3 extension table"> 
        <artwork><![CDATA[
+--------------------------------------------------+-------------+
| Extension                                        |     TLS 1.3 |
+--------------------------------------------------+-------------+
| tls_visibility                                   |      CH, SH |
+--------------------------------------------------+-------------+
]]>
        </artwork>
      </figure>

      <t>
        The Extension structure is defined in <xref
        target="I-D.ietf-tls-tls13"/>; it is repeated here for
        convenience.
      </t>

      <figure>
        <artwork><![CDATA[
  struct {
      ExtensionType extension_type;
      opaque extension_data<0..2^16-1>;
  } Extension;
]]>
        </artwork>
      </figure>

      <t>
        The "extension_type" identifies the particular extension type,
        and the "extension_data" contains information specific to the
        particular extension type.
      </t>

      <t>
        This document specifies the "tls_visibility" extension type,
        adding one new type to ExtensionType:
      </t>

      <figure>
        <artwork>
          <![CDATA[
  enum {
      tls_visibility(TBD), (65535)
  } ExtensionType;
]]>
        </artwork>
      </figure>

      <t>
        The "tls_visibility" extension is relevant when the client and
        server are enabling other parties to decrypt the TLS
        session.
      </t>
   
      <t>
        Clients MUST include the "tls_visibility" extension in the
        ClientHello message to indicate their willingness for other
        parties to decrypt the TLS session.  The server responds with
        data that enables the other parties to derive the keying
        material needed decryption the session if they are in
        possession of the indicated ECDH private key.
      </t>

      <figure>
        <artwork>
          <![CDATA[
  struct {
      select (Handshake.msg_type) {
          case client_hello:  Empty;
          case server_hello:  WrappedSessionSecrets visibility_data;
      };
  } TLSVisibilityExtension;

  struct {
      opaque early_secret<1..255>;
      opaque hs_secret<1..255>;
  } SessionSecrets;

  struct {
      opaque fingerprint<20>;
      opaque key_exchange<1..2^16-1>;
      opaque nonce<0..255>;
      opaque wrapped_secrets<1..2^16-1>;
  } WrappedSessionSecrets;
]]>
        </artwork>
      </figure>

      <t>
        The fields in WrappedSessionSecrets are used as follows:
        <list style="symbols">
          <t>
            "fingerprint" contains the leftmost 20 octets of the
            SHA-256 hash of WrapperDH1 public key that was used by the
            server to compute the session secret wrapping key.  The
            public key is DER-encoded in the SubjectPublicKeyInfo
            <xref target="RFC5280"/> for the SHA-256 hash computation.
            The key manager tells the server which AEAD algorithm to
            use with this WrapperDH1 public key at the time it is
            distributed.
          </t>

          <t>
            "key_exchange" contains the ephemeral WrapperDH2 public
            key generated by the server that is part of the same group
            as the WrapperDH1 public key identified by the "fingerprint".
            The server uses the ephemeral WrapperDH2 private key
            and the WrapperDH1 public key identified by the
            "fingerprint" to compute a shared secret value, called Z,
            and then uses HKDF <xref target="RFC5869"/> to produce the
            session secret wrapping key, called Ke, which uses an AEAD
            algorithm, such as AES-KEY-WRAP-256 <xref
            target="RFC5649"/> or AES-GCM-128 <xref target="GCM"/>.
            Ke is computed as follows:

            <figure>
              <artwork>
                <![CDATA[
PRK = HKDF-Extract(0x00, Z)
Ke = HKDF-Expand(PRK, "tls_visibility", AEAD_key_size)
]]>
              </artwork>
            </figure>
          </t>

          <t>
            "nonce" contains the nonce value for AEAD algorithm, if
            one is needed.  The "nonce" is zero length if one is not
            needed.
          </t>

          <t>
            "wrapped_secrets" contains the SessionSecrets structure
            encrypted with the AEAD algorithm under Ke.
          </t>
        </list>
      </t>

      <t>
        The fields in SessionSecrets are used as follows:

        <list style="symbols">
          <t>
            "early_secret" contains the Early Secret that was derived
            from the pre-shared key.  If this session did not use a
            pre-shared key, then the Early Secret is HKDF-Extract(0,
            0).
          </t>
   
          <t>
            "hs_secret" contains the handshake key that was computed
            using (EC)DHE.
          </t>
        </list>
      </t>
    </section>

    <section title="Alternative Approaches" anchor="section-alt">

      <t>
        This section captures the rationale for pursuing this approach
        to TLS visibility instead of the various alternative
        approaches.

        <list style="hanging">
          <t hangText="Server uses a static Diffie-Hellman key pair:">
            The private Diffie-Hellman key gets shared with the points
            that need visibility.  While this approach scales, the TLS
            client is unaware of the sharing.
          </t>
          
          <t hangText="Export of ephemeral keys:">
            In large enterprises there will be billions of ephemeral
            keys to export and distribute.  Transporting these keys to
            tools for decryption of packets in real time will be
            difficult, adding greatly to the complexity of the
            solution.
          </t>
          
          <t hangText="Export of decrypted traffic from TLS proxy devices:">
            Decrypting traffic only at the edge of the enterprise
            datacenter does not meet all of the enterprise
            requirements, which include troubleshooting, fraud
            detection, and network security monitoring.  Further, the
            number of TLS proxies needed are quite costly, add
            latency, and increase production risk.
          </t>
          
          <t hangText="Reliance on TCP/IP headers:">
            TCP and IP headers are not adequate for the enterprise
            requirements.  Troubleshooting, fraud detection, and
            network security monitoring need access to the plaintext
            payload.  For example, troubleshooters must be able to
            find specific transactions, user identifiers, session
            identifiers, URLs, and time stamps.
          </t>
          
          <t hangText="Reliance on application and server logs:">
            Logging is not adequate for enterprise requirements.  Code
            developers cannot anticipate every possible problem for
            logging, and system administrators turn much of the
            logging off for their installation.
          </t>
          
          <t hangText="Troubleshooting and malware analysis at the endpoint:">
            Endpoints are focused on providing a service, and they
            cannot handle the additional burden of the various
            enterprise monitoring requirements.
          </t>
          
          <t hangText="Adding TCP/UDP extensions:">
            An important part of troubleshooting, network security
            monitoring, etc. is analysis of the application-specific
            payload of the packet.  It is not possible to anticipate
            ahead of time, among thousands of unique applications,
            which fields in the application payload will be important.
          </t>
        </list>
      </t>
    </section>
    
    <section title="IANA Considerations" anchor="section-IANA">
      <t>
	IANA is requested to update the TLS ExtensionType Registry to
	include "tls_visibility" with a value of [TBD] and the list of
	messages "CH, SH" in which the "tls_visibility" extension may
	appear.
      </t>
    </section>
          
    <section title="Security Considerations" anchor="section-security">
      <t>The use of a TLS protocol extension ensures that both the client
and the server are aware that other parties have visibility into the TLS
session plaintext.  However, the approach used here does not allow those
parties to masquerade since they do not have the ability to sign the
Finished message in the TLS handshake.</t>

      <t>Use of the TLS Visibility extension represents a deliberate
introduction of parties other than the client and server that can access
the TLS session plaintext.  Deployments that who choose to make use of this
extension should carefully consider the risks associated with the change to
the Forward Secrecy.  In particular, Forward Secrecy will not begin until all
of these events take place:
        <list style="format (%d)">
          <t>The server has securely discarded the session secrets.</t>
          <t>The server has securely discarded the session secret wrapping key.</t>
          <t>The client has securely discarded the session secrets.</t>
          <t>The other parties have securely discarded the session secrets.</t>
          <t>The other parties have securely discarded the session secret wrapping key.</t>
          <t>The other parties have securely discarded the ECDHE private key that
was used to derive the session secret wrapping key.</t>
</list></t>

      <t>The ECDHE key size and parameters MUST be selected to provide the same
level (or more) of security as the (EC)DHE key used in the TLS Handshake.  Similarly,
the Sessions Secret Wrapping key size and algorithm MUST be selected to provide
the same level (or more) of security as the AEAD cipher usedwith the TLS Record
protocol.  If weaker key sizes, parameters or algorithms are used, the attacker
will find it easier to obtain the session secrets from the TLS Visibility extension.</t>
    </section>
    
    <section title="Acknowledgments" anchor="section-acks">
      <t>ACKNOWLEDGMENTS</t>
    </section>

  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.I-D.ietf-tls-tls13" ?>
      <?rfc include="reference.RFC.2119.xml"?>
      <?rfc include="reference.RFC.5280.xml"?>
      <?rfc include="reference.RFC.5869.xml"?>
    </references>
    <references title="Informative References">
      <reference anchor="GCM">
        <front>
          <title>The Galois/Counter Mode of Operation (GCM)</title>
          <author initials="D" surname="McGrew" fullname="David McGrew"/>
          <author initials="J" surname="Viega" fullname="John Viega"/>
          <date month="January" year="2004" />
        </front>
        <annotation>Submission to NIST. &lt;http://csrc.nist.gov/CryptoToolkit/modes/proposedmodes/gcm/gcm-spec.pdf&gt;</annotation>
      </reference>
      <?rfc include="reference.RFC.5649.xml"?>
    </references>
  </back>
  
</rfc>
        
